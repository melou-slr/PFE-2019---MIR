# -*- coding: utf-8 -*-
"""lastversion_preprocessing_SSMs+melspec_DOWNbeatsync.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TVexSlv_2bRc6__iDgBPSwTrIwW9KGXr
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import scipy.io
import matplotlib.pyplot as plt
from matplotlib import patches

from PIL import Image
import pylab as pyl

import tensorflow as tf
import keras
import sklearn
import h5py
import shutil
import scipy
import cython
import mido
import pytest
import six
import librosa

import IPython.display

from pathlib import Path

pip install --upgrade librosa

!pip install madmom

import madmom
import librosa
import librosa.display

import os
os.chdir('/content/drive/My Drive/Colab Notebooks/')
!pwd
import os.path
from os import path

#ID of SALAMI files for train set

idSALAMITrain = [792, 734,  1652,  636,  424,  790,  1068,  754,  1368,  836,  1528,  616,  412,  

1382,  838,  638,  348,  1296,  1446,  634,  666,  1160,  1432,  1184,  778,  

38,  1122,  640,  1182,  578,  1114,  184,  370,  1536,  526,  1444,  158,  

1614,  324,  1518,  1208,  630,  1352,  1276,  298,  1622,  1356,  1372,  476,  

1640,  1180,  466,  644,  1522,  588,  656,  10,  844,  1358,  276,  1042,  46,  

892,  44,  1526,  1436,  870,  362,  562,  328,  996,  1400,  364,  692,  1200,  

876,  1162,  1448,  1204,  752,  542,  1336,  1324,  600,  368,  720,  214,  

336,  1106,  188,  414,  1392,  1548,  730,  1574,  1148,  698,  970,  1494,  6,  

120,  1370,  494,  800,  1496,  820,  1116,  700,  1510,  242,  1210,  1650,  98,  

340,  608,  1172,  612,  678,  212,  486,  1082,  236,  318,  1482,  8,  622,  

1580,  400,  1328,  1498,  1096,  1252,  736,  190,  164,  1270,  1216,  1312,  

1540,  1512,  436,  366,  140,  584,  480,  32,  1572,  24,  934,  58,  334,  

146,  1304,  632,  492,  920,  1220,  1376,  1278,  1504,  1350,  474,  798,  

326,  1612,  350,  1226,  1396,  1084,  1520,  1560,  402,  1188,  388,  958,  

978,  1360,  446,  662,  310,  546,  12,  1454,  258,  846,  450,  1578,  550,  

294,  296,  1456,  404,  1570,  896,  68,  354,  534,  710,  244,  30,  568,  

852,  132,  1380,  234,  570,  946,  748,  1166,  1422,  448,  1418,  1406, 

460,  1344,  1408,  162,  596,  770,  806,  862,  4,  410,  1310,  112,  34,  

964,  1460,  1608,  36,  1154,  1128,  726,  260,  676,  924,  1330,  1238,  

278,  648,  1628,  598,  1390,  1624,  528,  406,  1420,  750,  740,  1388,  

756,  1582,  916,  386,  1412,  272,  1300,  1074,  1530,  228,  488,  152,  

1394,  1584,  114,  828,  360,  582,  1374,  1514,  490,  1164,  498,  724,  

762,  108,  428,  714,  786,  1146,  186,  1286,  372,  782,  1150,  1470,  940,  

54,  808,  696,  358,  728,  1130] 



#ID of SALAMI files for validation set

idSALAMIVal =  [746,  382,  956,  788,  832,  716,  116,  1158,  1490,  768,  

166,  78,  312,  760,  1386,  900,  1254,  812,  814,  860,  1090,  378,  1132,  

646,  614,  540,  1308,  1516,  882,  742,  930,  22,  864,  1156,  484,  818,  

628,  110,  462,  1206,  866,  1362,  1428,  510,  826,  652,  420] 



 

#ID of SALAMI files for test set

idSALAMITest = [1626,  92,  738,  944,  1476,  86,  

1282,  1506,  72,  620,  130,  1562,  954,  932,  802,  1340,  506,  1264,  604,  

1250,  254,  1214,  286,  1104,  118,  898,  1102,  1492,  912,  1248,  942,  

408,  478,  26,  1262,  1474,  878,  834,  1542,  52,  810,  1632,  984,  664,  

154,  982,  1066,  548,  1326,  1118,  642,  1638,  894,  104,  1272,  992,  

218,  962,  776,  1564,  1598,  14,  1290,  842,  1120,  1416,  1618,  524,  

1076,  522,  282,  1170,  874,  1586,  516,  1602,  890,  1112,  830,  948,  

518,  332,  886,  1110,  1378,  508,  1546,  1302,  610,  206,  374,  1152,  

302,  1136]

def trouver_la_liste(downbeats_frames,annot_frames):
  
  i=0
  liste=[]
  
  #trouver le premier annot sup ou egal au premier downbeat et apres ok pour faire tous les cas!
  
  for k in range (len(annot_frames)): 
    
    annot=annot_frames[k]
    
    while i<=len(downbeats_frames)-1 and downbeats_frames[i]<=annot:
      i=i+1
      
    if (i-1)<=len(downbeats_frames)-1 and  downbeats_frames[i-1]<=annot:
      liste.append(i-1)
      i=i+1
    else: 
      i+1
 
  return(liste)

def how_to_group_dico_mfcc(downbeats_frames,dico ):
  
  l_how_to_group=[]
  k=0
  i=0
  Z=np.zeros((13))
  dico=dico.T

  
  beats_division=beats_frames.tolist().index(downbeats_frames[2])-beats_frames.tolist().index(downbeats_frames[1])

  
  if beats_division==4:
    while k<=(len(dico)-1):
      M=dico[k]
      if k==(len(dico)-1):
        M=np.concatenate((M,Z), axis=0)
        M=np.concatenate((M,Z), axis=0)
        M=np.concatenate((M,Z), axis=0) 
      else:
        if k+1==(len(dico)-1):
          M=np.concatenate((M,dico[k+1]), axis=0)
          M=np.concatenate((M,Z), axis=0)
          M=np.concatenate((M,Z), axis=0)
        else:
          M=np.concatenate((M,dico[k+1]), axis=0)
          if k+2==(len(dico)-1):
            M=np.concatenate((M,dico[k+2]), axis=0)
            M=np.concatenate((M,Z), axis=0)
          else:
            M=np.concatenate((M,dico[k+2]), axis=0)
            M=np.concatenate((M,dico[k+3]), axis=0)
    
      k=k+4
      l_how_to_group.append(M)
      i=i+1
      
    
  if beats_division==3:
    while k<=(len(dico)-1):
    
      M=dico[k]
      if k==(len(dico)-1):
        M=np.concatenate((M,Z), axis=0)
        M=np.concatenate((M,Z), axis=0)
      else:
        if k+1==(len(dico)-1):
          M=np.concatenate((M,dico[k+1]), axis=0)
          M=np.concatenate((M,Z), axis=0)
        else:
          M=np.concatenate((M,dico[k+1]), axis=0)
          M=np.concatenate((M,dico[k+2]), axis=0)
      
      k=k+3
      l_how_to_group.append(M)
      i=i+1
      
    
  return (l_how_to_group)

def how_to_group_chromas(downbeats_frames,dico ):
  
  l_how_to_group=[]
  k=0
  i=0
  dico=dico.T
  Z=np.zeros((12))

  beats_division=beats_frames.tolist().index(downbeats_frames[2])-beats_frames.tolist().index(downbeats_frames[1])

  if beats_division==4:
    while k<=(len(dico)-1):
      M=dico[k]
      if k==(len(dico)-1):
        M=np.concatenate((M,Z), axis=0)
        M=np.concatenate((M,Z), axis=0)
        M=np.concatenate((M,Z), axis=0) 
      else:
        if k+1==(len(dico)-1):
          M=np.concatenate((M,dico[k+1]), axis=0)
          M=np.concatenate((M,Z), axis=0)
          M=np.concatenate((M,Z), axis=0)
        else:
          M=np.concatenate((M,dico[k+1]), axis=0)
          if k+2==(len(dico)-1):
            M=np.concatenate((M,dico[k+2]), axis=0)
            M=np.concatenate((M,Z), axis=0)
          else:
            M=np.concatenate((M,dico[k+2]), axis=0)
            M=np.concatenate((M,dico[k+3]), axis=0)
    
      k=k+4
      l_how_to_group.append(M)
      i=i+1
      
    
  if beats_division==3:
    while k<=(len(dico)-1):
    
      M=dico[k]
      if k==(len(dico)-1):
        M=np.concatenate((M,Z), axis=0)
        M=np.concatenate((M,Z), axis=0)
      else:
        if k+1==(len(dico)-1):
          M=np.concatenate((M,dico[k+1]), axis=0)
          M=np.concatenate((M,Z), axis=0)
        else:
          M=np.concatenate((M,dico[k+1]), axis=0)
          M=np.concatenate((M,dico[k+2]), axis=0)
      
      k=k+3
      l_how_to_group.append(M)
      i=i+1
      
   
    
  return (l_how_to_group)

!pip install essentia

import essentia, essentia.standard as ess

  hamming_window = ess.Windowing(type='hamming')
  spectrum = ess.Spectrum()  # we just want the magnitude spectrum
  mfcc = ess.MFCC(numberCoefficients=13)
  frame_sz = 1024
  hop_sz = 512

def decoupe_beats_in4parts(beats_frames):

  l=[]
  for k in range (len(beats_frames)-1): 
    
    milieu1=round((beats_frames[k+1]-beats_frames[k])/2)
    sub_beat2=beats_frames[k]+milieu1
    milieu2=round((sub_beat2-beats_frames[k])/2)
    sub_beat1=beats_frames[k]+milieu2
    milieu3=round((beats_frames[k+1]-sub_beat2)/2)
    sub_beat3=sub_beat2+milieu3
    
    l.append(beats_frames[k])
    l.append(sub_beat1)
    l.append(sub_beat2)
    l.append(sub_beat3)
  
  diff=sub_beat2-sub_beat1
  l.append(beats_frames[len(beats_frames)-1])  
  l.append(beats_frames[len(beats_frames)-1]+diff)
  l.append(beats_frames[len(beats_frames)-1]+2*diff)
  l.append(beats_frames[len(beats_frames)-1]+3*diff)
  
  l=[ int(x) for x in l ]
  l=np.array(l)  
  return l

def get_dico_peaks(beats_frames, peaks,o_env):
  i=0
  somme=0
  dico_peak={}
  beat_old=0

  for k in range (len(beats_frames)): 
    beat=beats_frames[k]
    while i<=len(peaks)-1 and peaks[i]>=beat_old and peaks[i]<beat:
      somme=somme+o_env[peaks[i]]
      i=i+1
    dico_peak[k]=somme
    somme=0
    beat_old=beat
    
  
  if i<=len(peaks)-1 and peaks[i]>=beat_old:
    for m in range (i,len(peaks)):
      somme=somme+o_env[peaks[m]]
    dico_peak[k+1]=somme
    
  else:
    dico_peak[k+1]=0
 
    
  return dico_peak

def how_to_group_dico_subdiv4(downbeats_frames, dico_peak):
  
  dico_how_to_group={}
  k=1
  liste=[]
  i=0

  beats_division=beats_frames.tolist().index(downbeats_frames[2])-beats_frames.tolist().index(downbeats_frames[1])

  if beats_division==4:
    while (k+3)<=(len(dico_peak)-1):
    
      liste.append(dico_peak[k])
      liste.append(dico_peak[k+1])
      liste.append(dico_peak[k+2])
      liste.append(dico_peak[k+3])
      
      if (k+3)==(len(dico_peak)-1):
        liste.append(0)
        liste.append(0)
        liste.append(0)
        liste.append(0)
        
        liste.append(0)
        liste.append(0)
        liste.append(0)
        liste.append(0)
        
        liste.append(0)
        liste.append(0)
        liste.append(0)
        liste.append(0)
        
      
      else:
              
        if (k+7)==(len(dico_peak)-1):
          liste.append(dico_peak[k+4])
          liste.append(dico_peak[k+5])
          liste.append(dico_peak[k+6])
          liste.append(dico_peak[k+7])
          
          liste.append(0)
          liste.append(0)
          liste.append(0)
          liste.append(0)
          
          liste.append(0)
          liste.append(0)
          liste.append(0)
          liste.append(0)
          
        else:
          liste.append(dico_peak[k+4])
          liste.append(dico_peak[k+5])
          liste.append(dico_peak[k+6])
          liste.append(dico_peak[k+7])
          
          if (k+11)==(len(dico_peak)-1):
            
            liste.append(dico_peak[k+8])
            liste.append(dico_peak[k+9])
            liste.append(dico_peak[k+10])
            liste.append(dico_peak[k+11])
          
            liste.append(0)
            liste.append(0)
            liste.append(0)
            liste.append(0)
            
          else:
            liste.append(dico_peak[k+8])
            liste.append(dico_peak[k+9])
            liste.append(dico_peak[k+10])
            liste.append(dico_peak[k+11])
            
            liste.append(dico_peak[k+12])
            liste.append(dico_peak[k+13])
            liste.append(dico_peak[k+14])
            liste.append(dico_peak[k+15])
    
      k=k+16
      dico_how_to_group[i]=liste
      i=i+1
      liste=[]
      
    
  if beats_division==3:
    while (k+3)<=(len(dico_peak)-1):
    
      liste.append(dico_peak[k])
      liste.append(dico_peak[k+1])
      liste.append(dico_peak[k+2])
      liste.append(dico_peak[k+3])
      if (k+3)==(len(dico_peak)-1):
        liste.append(0)
        liste.append(0)
        liste.append(0)
        liste.append(0)
        
        liste.append(0)
        liste.append(0)
        liste.append(0)
        liste.append(0)
      else:
        if (k+7)==(len(dico_peak)-1):
          liste.append(dico_peak[k+4])
          liste.append(dico_peak[k+5])
          liste.append(dico_peak[k+6])
          liste.append(dico_peak[k+7])
          
          liste.append(0)
          liste.append(0)
          liste.append(0)
          liste.append(0)
        else:
          liste.append(dico_peak[k+4])
          liste.append(dico_peak[k+5])
          liste.append(dico_peak[k+6])
          liste.append(dico_peak[k+7])
          
          liste.append(dico_peak[k+8])
          liste.append(dico_peak[k+9])
          liste.append(dico_peak[k+10])
          liste.append(dico_peak[k+11])
      
      k=k+12
      dico_how_to_group[i]=liste
      i=i+1
      liste=[]
    
  
  return (dico_how_to_group)

for i in idSALAMITest:
  val=i
  F=50
    
  y,sr=librosa.load('/content/drive/My Drive/Colab Notebooks/PFE/SALAMI/'+str(i)+'.mp3')
  y_later_use=y
  proc = madmom.features.downbeats.DBNDownBeatTrackingProcessor(beats_per_bar=[3, 4], fps=100)
  act = madmom.features.downbeats.RNNDownBeatProcessor()(y)
  estimated = proc(act)
  beats = estimated[:,0]
  beats_frames=librosa.core.time_to_frames(beats, sr=sr*2)
  downbeats = beats[estimated[:,1]==1]
  downbeats_frames=librosa.core.time_to_frames(downbeats, sr=sr*2)
  
  
  o_env = librosa.onset.onset_strength(y, sr=sr,hop_length=512,aggregate=np.median)
  peaks = librosa.util.peak_pick(o_env, 3, 3, 3, 5, 0.5, 2) 
  times = librosa.frames_to_time(np.arange(len(o_env)), sr=sr,hop_length=512)
 
   
  # Set the hop length; at 22050 Hz, 512 samples ~= 23ms
  hop_length = 512

  # Separate harmonics and percussives into two waveforms
  y_harmonic, y_percussive = librosa.effects.hpss(y)
 

  # Compute MFCC features from the raw signal
  mfccs = np.array([mfcc(spectrum(hamming_window(frame)))[1]
               for frame in ess.FrameGenerator(y, frameSize=frame_sz, hopSize=hop_sz)])
  mfccs = sklearn.preprocessing.scale(mfccs)
  
  beats_frames=np.insert(beats_frames,0, 0)
  beats_frames=np.append(beats_frames,len(mfccs)-1)
  
  
  if 0 not in downbeats_frames :
    downbeats_frames=np.insert(downbeats_frames,0, 0)
  if (len(mfccs)-1) not in downbeats_frames :
    downbeats_frames=np.append(downbeats_frames,len(mfccs)-1)
    
  
  if path.exists('/content/drive/My Drive/Colab Notebooks/PFE/SALAMI_annotations/annotations/'+str(i)+'/parsed/textfile1_functions.txt'):
    txt1 = Path('/content/drive/My Drive/Colab Notebooks/PFE/SALAMI_annotations/annotations/'+str(i)+'/parsed/textfile1_functions.txt').read_text()
    for t in txt1:
      if t!='0' and t!='1' and t!='2' and t!='3' and t!='4' and t!='5' and t!='6' and t!='7' and t!='8' and t!='9' and t!='.':
        txt1 = txt1.replace(t,' ')
    annot_s1=txt1.split()
    annot_sec1=list(map(float, annot_s1))
    annot_frames1=librosa.core.time_to_frames(annot_sec1, sr=sr)
    liste1=trouver_la_liste(downbeats_frames,annot_frames1)
    
  else:
    liste1=[]
  
  if path.exists('/content/drive/My Drive/Colab Notebooks/PFE/SALAMI_annotations/annotations/'+str(i)+'/parsed/textfile2_functions.txt'):
    txt2 = Path('/content/drive/My Drive/Colab Notebooks/PFE/SALAMI_annotations/annotations/'+str(i)+'/parsed/textfile2_functions.txt').read_text()   
    for t in txt2:
      if t!='0' and t!='1' and t!='2' and t!='3' and t!='4' and t!='5' and t!='6' and t!='7' and t!='8' and t!='9' and t!='.':
        txt2 = txt2.replace(t,' ')
    annot_s2=txt2.split()
    annot_sec2=list(map(float, annot_s2))
    annot_frames2=librosa.core.time_to_frames(annot_sec2, sr=sr)
    liste2=trouver_la_liste(downbeats_frames,annot_frames2)
    
  else:
    liste2=[]  

  
  beat_mfcc=librosa.util.sync(mfccs.T,beats_frames)
  
  downbeat_mfcc=how_to_group_dico_mfcc(downbeats_frames, beat_mfcc)

  # Compute chroma features from the harmonic signal
  chromagram = librosa.feature.chroma_cqt(y=y_harmonic,
                                        sr=sr)

  # Aggregate chroma features between beat events
  # We'll use the median value of each feature between beat frames
  beat_chroma = librosa.util.sync(chromagram,
                                beats_frames,
                                aggregate=np.median)
  
  downbeat_chromas=how_to_group_chromas(downbeats_frames, beat_chroma)

  R_aff_chroma = librosa.segment.recurrence_matrix(downbeat_chromas, mode='affinity',metric='cosine',self=True,axis=0)
  R_aff_mfcc = librosa.segment.recurrence_matrix(downbeat_mfcc, mode='affinity',metric='cosine',self=True,axis=0)
  
  
  R_aff_chroma=np.pad(R_aff_chroma, (25,25), 'constant', constant_values=(0, 0))
  R_aff_mfcc=np.pad(R_aff_mfcc, (25,25), 'constant', constant_values=(0, 0))
  
  
  listefusion=liste1
  for i in range (len(liste2)):
    if liste2[i] not in liste1:
      listefusion.append(liste2[i])    
  
  dico_sousmatrice_SMJ1={}
  for k in range (int(F/2),int(len(R_aff_chroma)-F/2)):
    m= np.zeros((F,F))
    for x in range (0,F-1):
      for y in range (0,F-1):
        m[x][y]=R_aff_chroma[int(x+(k-F/2))][int(y+(k-F/2))]
              
    dico_sousmatrice_SMJ1[k-int(F/2)]=m
    
    
  dico_sousmatrice_SMJ2={}
  for k in range (int(F/2),int(len(R_aff_chroma)-F/2)):
    m= np.zeros((F,F))
    for x in range (0,F-1):
      for y in range (0,F-1):
        m[x][y]=R_aff_mfcc[int(x+(k-F/2))][int(y+(k-F/2))]
              
    dico_sousmatrice_SMJ2[k-int(F/2)]=m 
    
 
  #partie où on sauve avec chromas&mfcss
  cl=np.zeros((50,50))
  cl=Image.fromarray(np.uint8(cl*255), 'L')
  for j in range(len(dico_sousmatrice_SMJ1)):
    im1=dico_sousmatrice_SMJ1[j]
    im2=dico_sousmatrice_SMJ2[j]
    im_chroma=Image.fromarray(np.uint8(im1*255), 'L')
    im_mfcc=Image.fromarray(np.uint8(im2*255), 'L')
    merged=Image.merge("RGB",(cl, im_mfcc, im_chroma))
    
    if j in listefusion:
      merged.save('/content/drive/My Drive/Colab Notebooks/Salami preprocessing_downbeatsync/SSMs_without_metergram/Test/Test/SSM_segment_sousmatrice'+str(val)+'_'+str(j)+'.jpeg')
    else:
      merged.save('/content/drive/My Drive/Colab Notebooks/Salami preprocessing_downbeatsync/SSMs_without_metergram/Test/Test/SSM_sousmatrice'+str(val)+'_'+str(j)+'.jpeg')
       
  
  #part specific for the metergram:
  
 
  l=decoupe_beats_in4parts(beats_frames)
  dico_peak2=get_dico_peaks(l, peaks, o_env)
  dico_how_to_group2=how_to_group_dico_subdiv4(downbeats_frames, dico_peak2)

  orderedNames=[]
  for key in sorted(dico_how_to_group2):
    orderedNames.append(key)
 
  dataMatrix = np.array([dico_how_to_group2[i] for i in orderedNames])
  #M=dataMatrix.T
  
  R_aff_meter = librosa.segment.recurrence_matrix(dataMatrix, mode='affinity',metric='cosine',self=True,axis=0)
  R_aff_meter = np.pad(R_aff_meter, (25,25), 'constant', constant_values=(0, 0))
  
  
  dico_sousmatrice_SMJ3={}
  for k in range (int(F/2),int(len(R_aff_chroma)-F/2)):
    m= np.zeros((F,F))
    for x in range (0,F-1):
      for y in range (0,F-1):
        m[x][y]=R_aff_meter[int(x+(k-F/2))][int(y+(k-F/2))]
              
    dico_sousmatrice_SMJ3[k-int(F/2)]=m
    
    
  #partie où on sauve avec le metergram en plus:
  
  for j in range(len(dico_sousmatrice_SMJ1)):
    im1=dico_sousmatrice_SMJ1[j]
    im2=dico_sousmatrice_SMJ2[j]
    im3=dico_sousmatrice_SMJ3[j]
    im_chroma=Image.fromarray(np.uint8(im1*255), 'L')
    im_mfcc=Image.fromarray(np.uint8(im2*255), 'L')
    im_meter=Image.fromarray(np.uint8(im3*255), 'L')
    merged=Image.merge("RGB",(im_meter, im_mfcc, im_chroma))
    
    
    if j in listefusion:
      merged.save('/content/drive/My Drive/Colab Notebooks/Salami preprocessing_downbeatsync/SSMs_with_metergram/Test/Test/SSM_segment_sousmatrice'+str(val)+'_'+str(j)+'.jpeg')
    else:
      merged.save('/content/drive/My Drive/Colab Notebooks/Salami preprocessing_downbeatsync/SSMs_with_metergram/Test/Test/SSM_sousmatrice'+str(val)+'_'+str(j)+'.jpeg')
          
  
  mel=librosa.feature.melspectrogram(y=y_later_use, sr=sr,n_mels=80)
  beat_mel = librosa.util.sync(mel,downbeats_frames)
  b_m=librosa.power_to_db(beat_mel,ref=np.max)
  
  mel_padded=np.zeros(shape=(80,len(b_m.T)+F)) 

  for i in range(len(b_m)):
    x=np.insert(b_m[i], 0, -70*np.ones(25))
    x=np.append(x,-70*np.ones(25))
    mel_padded[i]=x
    
  t_m=mel_padded.T
  dico_sousmatrice_melspectro={}
  for k in range (int(F/2),int(len(mel_padded.T)-F/2)):
  
    m= np.zeros(shape=(F,80))
    for x in range (0,F):
      
        m[x]=t_m[int(x+(k-F/2))]
        
    m=m.T          
    dico_sousmatrice_melspectro[k-int(F/2)]=m        
  
  
  #partie où on sauve melspectrog
  for i in range(len(dico_sousmatrice_melspectro)):
    OL=dico_sousmatrice_melspectro[i]
    m=OL/(-80)
    im=Image.fromarray(np.uint8(m*255), 'L')
    
    if i in listefusion:
      im.save('/content/drive/My Drive/Colab Notebooks/Salami preprocessing_downbeatsync/melspectrog/Test/Test/melspect_segment_sousmatrice'+str(val)+'_'+str(i)+'.jpeg')
    else:
      im.save('/content/drive/My Drive/Colab Notebooks/Salami preprocessing_downbeatsync/melspectrog/Test/Test/melspect_sousmatrice'+str(val)+'_'+str(i)+'.jpeg')